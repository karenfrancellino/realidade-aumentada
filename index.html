<!DOCTYPE html> <!-- Diz que o documento Ã© HTML5 -->

<html>
  <head> <!-- Ãrea de configuraÃ§Ãµes e importaÃ§Ãµes do projeto -->
    <!-- Define que o texto da pÃ¡gina usa UTF-8 (acentos e emojis nÃ£o quebram) -->
    <meta charset="utf-8">
    <!-- Ajusta a visualizaÃ§Ã£o em celulares para ocupar toda a tela -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- Permite que a pÃ¡gina funcione como "app" no iPhone -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <!-- Permite que a pÃ¡gina funcione como "app" no Android -->
    <meta name="mobile-web-app-capable" content="yes">
    <!-- Importa A-Frame â†’ a biblioteca que cria objetos 3D -->
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <!-- Permite movimento do personagem -->
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.2.0/dist/aframe-extras.min.js"></script>
    <!-- Importa AR.js â†’ a biblioteca que ativa a Realidade Aumentada -->
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
     <!-- Importa biblioteca para screenshot-->
    <script src="https://cdn.webrtc-experiment.com/RecordRTC.js"></script>
    <!-- Ferramenta para acionar tela ceheia nos dispositivos maiores-->
<style>
  canvas {
    width: 100% !important;
    height: 100% !important;
    left: 0 !important;
    top: 0 !important;
    position: absolute !important;
  }
</style>
  </head>
  <!-- O que aparece na tela comeÃ§a no body + margin:0 â†’ tira margens da pÃ¡gina + overflow:hidden â†’ remove barras de rolagem para a cÃ¢mera ocupar a tela -->
  <body style="margin:0; overflow:hidden;">
    <!-- Inicia a cena 3D + AR.js + Impede modo VR e deixa cena embutida na pÃ¡gina + Diz que a fonte do vÃ­deo Ã© a webcam/cÃ¢mera -->
   <a-scene embedded 
  renderer="preserveDrawingBuffer: true; alpha: true;" 
  arjs="sourceType: webcam; videoTexture: true;"> <!-- videoTexture: true funde a cena do personagem com a da camera + preserveDrawingBuffer: true;Impede que o navegador limpe o buffer do desenho logo apÃ³s renderizar -->
      <!-- MARCADOR HIRO + Quando a cÃ¢mera detectar o marcador Hiro, tudo dentro aparece -->
      <a-marker preset="hiro">
        <!-- Adiciona id ao personagem + OBJETO 3D + Um personagem droys posicionada 0.5m acima do marcador -->
  <a-entity
    id="personagem"
    gltf-model="https://raw.githubusercontent.com/KarenFrancellino/ar-models/main/DROYZ_ANIMAPP_SiCkJacken_v005.glb"
    scale="3 3 3"
    position="0 0.5 0"
    animation-mixer>
  </a-entity>
      </a-marker>
      <!-- CÃ‚MERA + A cÃ¢mera usada para visualizar a RA -->
      <a-entity camera></a-entity>
  </a-scene>
     <!-- Ancora para os botoes -->
      <div style="position: fixed; bottom: 20px; width: 100%; display: flex; justify-content: space-around; z-index: 10000; pointer-events: none;">
     <!-- Botao screenshot -->
    <button id="btnScreenshot" style="pointer-events: auto; padding: 15px 20px; background: white; border-radius: 12px; border: 2px solid #333; font-weight: bold; box-shadow: 0px 4px 6px rgba(0,0,0,0.2);">
      ðŸ“¸ Tirar Foto
    </button>
    <!-- Botao gravaÃ§ao de tela -->
    <button id="btnRecord" style="pointer-events: auto; padding: 15px 20px; background: white; border-radius: 12px; border: 2px solid #333; font-weight: bold; box-shadow: 0px 4px 6px rgba(0,0,0,0.2);">
      ðŸ”´ Gravar VÃ­deo
    </button>
</div>

    <script>
      // Variaveis
    const personagem = document.querySelector('#personagem'); // Variavel personagem
    const btnFoto = document.querySelector('#btnScreenshot'); // Variavel print da tela
    const btnVideo = document.querySelector('#btnRecord'); // Variavel gravar tela 
    const canvas = document.querySelector('canvas'); // Variavel responsavel por vincular as camadas de imagem, personage + camera
    const SickJacken_rigAction = "SickJacken_rigAction"; // Variavel para chamar aÃ§ao do personagem

     // AÃ§Ã£o de carregar o personagem
personagem.addEventListener('model-loaded', (e) => {
    
    const model = e.detail.model;  // Solicita o arquivo 3D
    const animations = model.animations; // Solicita aÃ§ao do personagem do aquivo 3D
  
// Ativa a animaÃ§ao se tiver
    if (animations.length > 0) {
      // Configura o componente 'animation-mixer' para tocar a animaÃ§Ã£o desejada
        personagem.setAttribute('animation-mixer', {
            clip: SickJacken_rigAction, // Inicia a aÃ§ao do personagem
            loop: 'repeat' // Faz a animaÃ§Ã£o repetir infinitamente
        });
      
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  console.warn('Nenhuma animaÃ§Ã£o encontrada no modelo.'); // Mensagem de aviso se nenhuma animaÃ§Ã£o for encontrada
Â  Â  Â  Â  }
Â  Â  Â  });

      // --------------------------------------------------------
      // LÃ“GICA DE SCREENSHOT 
      // --------------------------------------------------------
      // Seleciona o elemento <a-scene> (a cena)
btnFoto.addEventListener('click', () => {
    
    // Tira a "foto" do que estÃ¡ passando no canvas agora
    const dadosDaImagem = canvas.toDataURL("image/png");
    // Cria um link invisÃ­vel para "enganar" o navegador e baixar o arquivo
    const linkTemporario = document.createElement('a');
    linkTemporario.download = "minha-foto-ar.png"; // Nome do arquivo que serÃ¡ salvo
    linkTemporario.href = dadosDaImagem;
    // 3. Simula o clique no link para iniciar o download
    linkTemporario.click();
    
    // Alerta de captura de tela 
    alert('Foto capturada com sucesso!');
}); 

      // --------------------------------------------------------
      // LÃ“GICA DE GRAVAÃ‡ÃƒO DE VÃDEO
      // --------------------------------------------------------
let gravador; // VariÃ¡vel para armazenar a instÃ¢ncia do RecordRTC
let gravando = false;  // VariÃ¡vel de estado para saber se estÃ¡ gravando

btnVideo.addEventListener('click', () => {
     // --- LÃ“GICA PARA INICIAR GRAVAÃ‡ÃƒO ---
    if (gravando === false) {
        // --- AÃ‡ÃƒO A: LIGAR A GRAVAÃ‡ÃƒO ---
        
        // Captura o fluxo de imagens do canvas (30 quadros por segundo)
        const fluxoDoCanvas = canvas.captureStream(30);
        
        // Prepara o RecordRTC com esse fluxo
        gravador = new RecordRTC(fluxoDoCanvas, {
            type: 'video',
            mimeType: 'video/webm'
        });

        // Aperta o "Rec" e avisa o sistema
        gravador.startRecording();
        gravando = true;
        
        // Muda o visual do botÃ£o para o usuÃ¡rio saber que estÃ¡ gravando
        btnVideo.textContent = 'â¹ Parar GravaÃ§Ã£o';
        btnVideo.style.backgroundColor = 'red';
        btnVideo.style.color = 'white';

    } else {
        // --- AÃ‡ÃƒO B: DESLIGAR E SALVAR ---
        
        gravador.stopRecording(() => {
            // Transforma os dados gravados em um arquivo (Blob)
            const arquivoVideo = gravador.getBlob();
            
            // Cria o link de download
            const urlVideo = URL.createObjectURL(arquivoVideo);
            const linkDownload = document.createElement('a');
            linkDownload.href = urlVideo;
            linkDownload.download = 'meu-video-ar.webm';
            
            // Baixa o arquivo
            linkDownload.click();
            
            // Reseta tudo para o estado original
            gravando = false;
            btnVideo.textContent = 'ðŸ”´ Gravar VÃ­deo';
            btnVideo.style.backgroundColor = 'white';
            btnVideo.style.color = 'black';
        });
    }
});
Â  Â  </script>
  </body>
</html>
