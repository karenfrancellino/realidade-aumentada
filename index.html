<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"> <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script> <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script> <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script> </head>

<body style="margin:0; overflow:hidden;"> <a-scene embedded 
    renderer="preserveDrawingBuffer: true; alpha: true; antialias: true; colorManagement: true;" 
    arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;">

    <a-marker preset="hiro"> <a-entity
        id="personagem"
        gltf-model="https://raw.githubusercontent.com/KarenFrancellino/ar-models/main/DROYZ_ANIMAPP_SiCkJacken_v005.glb"
        scale="2 2 2"
        position="0 0.5 0"
        animation-mixer="clip: SickJacken_rigAction; loop: repeat; timeScale: 1"> </a-entity>
    </a-marker>
    
    <a-entity camera></a-entity> </a-scene>

  <div style="position:absolute; bottom:20px; width:100%; display:flex; justify-content:space-around; z-index:999;">
    <button id="screenshotButton" style="padding:15px; background:white; border-radius:10px; border:none; font-weight:bold;">ğŸ“¸ Hacer Foto</button>
    <button id="recordButton" style="padding:15px; background:white; border-radius:10px; border:none; font-weight:bold;">ğŸ”´ Grabar VÃ­deo</button>
  </div>

  <script>
    const scene = document.querySelector('a-scene'); // Referencia a cena principal
    const recordButton = document.querySelector('#recordButton'); // Referencia o botÃ£o de vÃ­deo
    const screenshotButton = document.querySelector('#screenshotButton'); // Referencia o botÃ£o de foto
    let recorder; // VariÃ¡vel para armazenar a instÃ¢ncia do MediaRecorder
    let chunks = []; // Array para armazenar os pacotes de dados do vÃ­deo

    /**
     * FUNÃ‡ÃƒO TÃ‰CNICA: Mescla o vÃ­deo da Webcam com o Canvas 3D.
     * NecessÃ¡rio porque o AR.js separa a cÃ¢mera (HTML Video) do modelo (HTML Canvas).
     */
    function captureMergedCanvas() {
      const video = document.querySelector('video'); // Captura o elemento de vÃ­deo da webcam gerado pelo AR.js
      const canvas3d = scene.renderer.domElement; // Captura o canvas WebGL onde o personagem Ã© renderizado
      const outputCanvas = document.createElement('canvas'); // Cria um canvas temporÃ¡rio em memÃ³ria
      outputCanvas.width = canvas3d.width; // Sincroniza a largura
      outputCanvas.height = canvas3d.height; // Sincroniza a altura
      const ctx = outputCanvas.getContext('2d'); // ObtÃ©m o contexto 2D para desenho

      ctx.drawImage(video, 0, 0, outputCanvas.width, outputCanvas.height); // Desenha o frame atual da cÃ¢mera ao fundo
      ctx.drawImage(canvas3d, 0, 0); // Desenha o personagem 3D por cima (mantendo a transparÃªncia)
      return outputCanvas; // Retorna o canvas mesclado
    }

    // LÃ³gica de Foto (Screenshot)
    screenshotButton.addEventListener('click', () => {
      const mergedCanvas = captureMergedCanvas(); // ObtÃ©m a imagem combinada
      const dataURL = mergedCanvas.toDataURL('image/png'); // Converte o canvas para uma URL de imagem base64
      const link = document.createElement('a'); // Cria um elemento de Ã¢ncora invisÃ­vel
      link.href = dataURL; // Atribui a imagem ao link
      link.download = 'ar-capture.png'; // Define o nome do arquivo de saÃ­da
      link.click(); // Simula o clique para iniciar o download
      screenshotButton.textContent = 'âœ…'; // Feedback visual rÃ¡pido
      setTimeout(() => screenshotButton.textContent = 'ğŸ“¸ Hacer Foto', 2000); // Restaura o texto original
    });

    // LÃ³gica de VÃ­deo
    recordButton.addEventListener('click', () => {
      if (!recorder || recorder.state === 'inactive') {
        chunks = []; // Limpa gravaÃ§Ãµes anteriores
        // Captura o stream do canvas 3D. Nota: capturar o merge em tempo real exige processamento intenso via requestAnimationFrame.
        const stream = scene.renderer.domElement.captureStream(30); 
        recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp8' }); // Inicializa o gravador no formato WebM

        recorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); }; // Empilha os dados gravados no array
        recorder.onstop = () => {
          const blob = new Blob(chunks, { type: 'video/webm' }); // Transforma os dados em um arquivo Blob
          const url = URL.createObjectURL(blob); // Cria uma URL temporÃ¡ria para o arquivo
          const a = document.createElement('a'); // Cria link para download
          a.href = url;
          a.download = 'ar-video.webm';
          a.click(); // Executa o download
        };

        recorder.start(); // Inicia o processo de gravaÃ§Ã£o
        recordButton.textContent = 'â¹ Parar'; // Altera interface
        recordButton.style.background = 'red';
      } else {
        recorder.stop(); // Finaliza a gravaÃ§Ã£o e dispara o evento onstop
        recordButton.textContent = 'ğŸ”´ Grabar VÃ­deo'; // Restaura interface
        recordButton.style.background = 'white';
      }
    });

    // Evento de verificaÃ§Ã£o de animaÃ§Ãµes no console para depuraÃ§Ã£o tÃ©cnica
    document.querySelector('#personagem').addEventListener('model-loaded', (e) => {
      const animations = e.detail.model.animations; // Acessa os dados de animaÃ§Ã£o dentro do arquivo GLB
      console.log('AnimaÃ§Ãµes detectadas:', animations.map(a => a.name)); // Lista nomes das animaÃ§Ãµes disponÃ­veis no log
    });
  </script>
</body>
</html>
