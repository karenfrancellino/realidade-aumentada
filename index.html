<!DOCTYPE html> 
<!-- Define que este documento √© HTML5 -->

<html>
  <head>
    <!-- √Årea de configura√ß√µes e importa√ß√µes do projeto -->

    <meta charset="utf-8">
    <!-- Define a codifica√ß√£o de caracteres como UTF-8 
         ‚Üí permite acentos, emojis e caracteres especiais sem problemas -->

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- Ajusta a tela em dispositivos m√≥veis
         width=device-width ‚Üí largura da tela do dispositivo
         initial-scale=1.0 ‚Üí zoom inicial
         user-scalable=no ‚Üí impede o zoom manual do usu√°rio -->

    <meta name="apple-mobile-web-app-capable" content="yes">
    <!-- Permite que a p√°gina funcione como "app" em iPhones -->

    <meta name="mobile-web-app-capable" content="yes">
    <!-- Permite que a p√°gina funcione como "app" em Android -->

    <!-- Importa A-Frame (biblioteca 3D) -->
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>

    <!-- Importa AR.js (Realidade Aumentada) -->
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

    <!-- Importa biblioteca para screenshot-->
    <script src="https://cdn.webrtc-experiment.com/RecordRTC.js"></script>
    
  </head> 
  <body style="margin:0; overflow:hidden;">
    <!-- margin:0 remove margens da p√°gina
         overflow:hidden remove barras de rolagem para c√¢mera ocupar toda a tela -->

    <!-- Cena 3D + AR.js -->
     <!-- Deixa a cena embutida na p√°gina, sem VR completo -->
    <!-- Define que a fonte de v√≠deo √© a webcam -->
    <a-scene 
      embedded                     
      arjs="sourceType: webcam;     
           debugUIEnabled: false;"> <!-- Remove os bot√µes de debug da AR -->

      <!-- Marcador Hiro -->
      <!-- Tudo que estiver dentro aparece quando o marcador Hiro √© detectado -->
      <a-marker preset="hiro">

        <!-- Entidade do personagem 3D -->
        <!-- ID para referenciar o modelo no script -->
         <!-- Ajusta o tamanho do modelo -->
        <!-- Posi√ß√£o relativa ao marcador -->
        <a-entity 
          id="personagem"  
          gltf-model="https://raw.githubusercontent.com/KarenFrancellino/ar-models/main/DROYZ_ANIMAPP_SiCkJacken_v005.glb"
          scale="2 2 2"  
          position="0 0.5 0" 
          animation-mixer> <!-- Ativa o sistema de anima√ß√£o do GLB -->
        </a-entity>

      </a-marker>

      <!-- C√¢mera -->
      <a-entity camera></a-entity>

      <!-- Tirar screenshot-->
      </a-scene> <button id="screenshotButton" style="position: absolute; bottom: 10px; left: 10px; z-index: 999; padding: 10px;">
    </a-scene>
</button> <!-- Grava√ßao de tela-->
    
    <button id="recordButton" style="position: absolute; bottom: 10px; right: 10px; z-index: 999; padding: 10px;"> 
      üî¥ Iniciar Grava√ß√£o 
    </button> 
  
    <!-- Script para descobrir anima√ß√µes e tocar a primeira -->
    <script>
      // Seleciona a entidade do modelo pelo ID
      const entity = document.querySelector('#personagem');

      // Espera o modelo carregar totalmente
      entity.addEventListener('model-loaded', (e) => {
        const model = e.detail.model;       // Objeto 3D carregado
        const animations = model.animations; // Lista de anima√ß√µes dispon√≠veis

        // Mostra no console todos os nomes das anima√ß√µes
        console.log('Anima√ß√µes dispon√≠veis:', animations.map(a => a.name));

        // Se houver anima√ß√µes, toca automaticamente a primeira
        if (animations.length > 0) {
          entity.setAttribute('animation-mixer', {
            clip: SickJacken_rigAction,  // Nome da anima√ß√£o a tocar
            loop: 'repeat'             // Faz a anima√ß√£o repetir infinitamente
          });
        } else {
          console.warn('Nenhuma anima√ß√£o encontrada no modelo.');
        }
      });
      // --------------------------------------------------------
      // L√ìGICA DE SCREENSHOT (NOVO)
      // --------------------------------------------------------
      // Seleciona o elemento <a-scene> (a cena)
      const scene = document.querySelector('a-scene'); 
      // Seleciona o bot√£o de screenshot
      const screenshotButton = document.querySelector('#screenshotButton'); 

      // Adiciona um 'listener' de clique ao bot√£o de screenshot
      screenshotButton.addEventListener('click', () => { 
        // Usa o componente 'screenshot' embutido do A-Frame para capturar e salvar a imagem
        scene.components.screenshot.capture('filename', 'ar-screenshot.png');
        // Alerta o usu√°rio
        alert('Screenshot capturado e salvo como ar-screenshot.png!');
      });

      // --------------------------------------------------------
      // L√ìGICA DE GRAVA√á√ÉO DE V√çDEO (NOVO)
      // --------------------------------------------------------
      
      let recorder; // Vari√°vel para armazenar a inst√¢ncia do RecordRTC
      const recordButton = document.querySelector('#recordButton'); // Seleciona o bot√£o de grava√ß√£o
      let isRecording = false; // Vari√°vel de estado para saber se est√° gravando

      // Adiciona um 'listener' de clique ao bot√£o de grava√ß√£o
      recordButton.addEventListener('click', () => { 
        if (!isRecording) {
          // --- L√ìGICA PARA INICIAR GRAVA√á√ÉO --- 
          
          const canvas = document.querySelector('canvas'); // Pega o elemento <canvas>
          
          // Captura o stream de v√≠deo do canvas (o que est√° sendo renderizado)
          const canvasStream = canvas.captureStream();
          
          // Cria uma nova inst√¢ncia do RecordRTC
          recorder = new RecordRTC(canvasStream, {
            type: 'video',         // Tipo v√≠deo
            mimeType: 'video/webm',// Formato webm
          });

          recorder.startRecording(); // Inicia a grava√ß√£o
          isRecording = true; // Atualiza o estado
          recordButton.textContent = '‚èπ Parar Grava√ß√£o'; // Altera o texto
          recordButton.style.backgroundColor = 'red'; // Destaca o bot√£o
          alert('Grava√ß√£o iniciada!'); // Alerta o usu√°rio
        } else {
          //  --- L√ìGICA PARA PARAR GRAVA√á√ÉO --- 
          
          // Para a grava√ß√£o e executa a fun√ß√£o de callback
          recorder.stopRecording(() => { 
            const blob = recorder.getBlob(); // Pega o arquivo de v√≠deo (Blob)
            
            // Cria link tempor√°rio para download
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); // Cria link <a>
            a.style.display = 'none'; // Oculta o link
            a.href = url; // Define o URL
            a.download = 'ar-video-recording.webm'; // Nome do arquivo
            document.body.appendChild(a); // Adiciona ao corpo
            a.click(); // Simula clique para download
            window.URL.revokeObjectURL(url); // Libera o URL
            
            isRecording = false; // Atualiza o estado
            recordButton.textContent = 'üî¥ Iniciar Grava√ß√£o'; // Restaura o texto
            recordButton.style.backgroundColor = ''; // Remove o destaque
            alert('Grava√ß√£o parada e salva como ar-video-recording.webm!'); // Alerta
          });
        }
      });
    </script>

  </body>
</html>
