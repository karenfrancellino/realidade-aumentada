<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"> <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script> <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script> <script src="https://cdn.jsdelivr.net/npm/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script> </head>

<body style="margin:0; overflow:hidden;"> <a-scene 
        embedded 
        vr-mode-ui="enabled: false"
        renderer="preserveDrawingBuffer: true; alpha: true; antialias: true;" 
        arjs="sourceType: webcam; debugUIEnabled: false;">

        <a-marker preset="hiro"> <a-entity
                id="personagem"
                gltf-model="https://raw.githubusercontent.com/KarenFrancellino/ar-models/main/DROYZ_ANIMAPP_SiCkJacken_v005.glb"
                scale="2 2 2"
                position="0 0.5 0"
                animation-mixer="clip: SickJacken_rigAction; loop: repeat"> </a-entity>
        </a-marker>
        
        <a-entity camera></a-entity> </a-scene>

    <div style="position:fixed; bottom:30px; width:100%; display:flex; justify-content:space-around; z-index:10000;">
        <button id="btnFoto" style="padding:20px; border-radius:50%; background:white; border:none; box-shadow:0 4px 15px rgba(0,0,0,0.4); font-size:24px;">üì∏</button>
        <button id="btnVideo" style="padding:20px; border-radius:50%; background:white; border:none; box-shadow:0 4px 15px rgba(0,0,0,0.4); font-size:24px;">üî¥</button>
    </div>

    <script>
        const cena = document.querySelector('a-scene'); // Refer√™ncia da cena A-Frame
        const btnFoto = document.querySelector('#btnFoto'); // Refer√™ncia do bot√£o de foto
        const btnVideo = document.querySelector('#btnVideo'); // Refer√™ncia do bot√£o de v√≠deo
        let gravador; // Inst√¢ncia do gravador MediaRecorder
        let blocos = []; // Array para armazenar os fragmentos (chunks) do v√≠deo

        // --- L√ìGICA DE FOTO (SCREENSHOT) ---
        btnFoto.addEventListener('click', () => {
            const video = document.querySelector('video'); // Acessa o elemento de v√≠deo da webcam
            const canvas3D = cena.renderer.domElement; // Acessa o canvas WebGL onde o personagem est√°
            
            const mergeCanvas = document.createElement('canvas'); // Cria um canvas tempor√°rio para fus√£o
            mergeCanvas.width = canvas3D.width; // Define largura igual √† resolu√ß√£o do renderizador
            mergeCanvas.height = canvas3D.height; // Define altura igual √† resolu√ß√£o do renderizador
            const ctx = mergeCanvas.getContext('2d'); // Obt√©m o contexto de desenho 2D

            // T√âCNICO: For√ßa o renderizador a desenhar o frame agora para n√£o vir vazio (corre√ß√£o para iOS)
            cena.renderer.render(cena.object3D, cena.camera); 

            // Passo 1: Desenha a imagem da webcam ao fundo
            ctx.drawImage(video, 0, 0, mergeCanvas.width, mergeCanvas.height);
            // Passo 2: Desenha o personagem 3D por cima (preservando transpar√™ncia)
            ctx.drawImage(canvas3D, 0, 0);

            const dataURL = mergeCanvas.toDataURL('image/png'); // Converte o resultado em uma imagem PNG
            const link = document.createElement('a'); // Cria um elemento de download invis√≠vel
            link.download = 'ar-foto.png'; // Nome do arquivo de sa√≠da
            link.href = dataURL; // Atribui o dado da imagem ao link
            link.click(); // Dispara o download autom√°tico
        });

        // --- L√ìGICA DE V√çDEO (GRAVA√á√ÉO) ---
        btnVideo.addEventListener('click', () => {
            if (!gravador || gravador.state === 'inactive') { // Verifica se n√£o h√° grava√ß√£o em curso
                const video = document.querySelector('video'); // Refer√™ncia da webcam
                const canvas3D = cena.renderer.domElement; // Refer√™ncia do personagem
                const mergeCanvas = document.createElement('canvas'); // Canvas para processar o v√≠deo mesclado
                mergeCanvas.width = canvas3D.width; // Sincroniza dimens√µes
                mergeCanvas.height = canvas3D.height;
                const ctx = mergeCanvas.getContext('2d');

                // T√âCNICO: Verifica formatos suportados. iOS prefere MP4/H264 se dispon√≠vel
                let tipoMime = 'video/mp4'; 
                if (!MediaRecorder.isTypeSupported(tipoMime)) {
                    tipoMime = 'video/webm;codecs=vp8'; // Padr√£o para Chrome/Android
                }

                const stream = mergeCanvas.captureStream(30); // Captura o fluxo do canvas a 30 quadros por segundo
                gravador = new MediaRecorder(stream, { mimeType: tipoMime }); // Inicia o gravador com o formato escolhido
                blocos = []; // Limpa o buffer de v√≠deo

                gravador.ondataavailable = e => blocos.push(e.data); // Acumula dados conforme s√£o gerados
                gravador.onstop = () => { // Evento disparado ao finalizar a grava√ß√£o
                    const blob = new Blob(blocos, { type: tipoMime }); // Cria um arquivo bin√°rio (Blob)
                    const url = URL.createObjectURL(blob); // Gera uma URL para o arquivo criado
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `ar-video.${tipoMime.includes('mp4') ? 'mp4' : 'webm'}`; // Define extens√£o correta
                    link.click(); // Inicia o download
                };

                gravador.start(); // Inicia o processo de captura
                btnVideo.textContent = "‚èπÔ∏è"; // Altera √≠cone para "Parar"
                btnVideo.style.background = "#ff4d4d"; // Feedback visual de grava√ß√£o

                // LOOP DE RENDERIZA√á√ÉO: Mescla webcam e 3D frame a frame para o v√≠deo
                function loop() {
                    if (gravador && gravador.state === 'recording') {
                        ctx.drawImage(video, 0, 0, mergeCanvas.width, mergeCanvas.height); // Webcam fundo
                        ctx.drawImage(canvas3D, 0, 0); // 3D frente
                        requestAnimationFrame(loop); // Chama o pr√≥ximo frame sincronizado com a tela
                    }
                }
                loop(); // Inicia o loop
            } else {
                gravador.stop(); // Finaliza a grava√ß√£o
                btnVideo.textContent = "üî¥"; // Restaura √≠cone original
                btnVideo.style.background = "white"; // Restaura cor original
            }
        });
    </script>
</body>
</html>
